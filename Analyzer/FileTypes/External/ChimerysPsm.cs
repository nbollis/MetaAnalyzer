using Analyzer.Util.TypeConverters;
using AnalyzerCore;
using CsvHelper.Configuration.Attributes;
using Omics.Modifications;
using ResultAnalyzerUtil;
using System.Text;

namespace Analyzer.FileTypes.External;

/// <summary>
/// Represents a PSM generated by Chimerys (v4.3.0) when ran on the Msaid platform (v1.5.6)
/// </summary>
public class ChimerysPsm : ISpectralMatch
{
    [Ignore] public int Charge => PrecursorCharge;
    [Ignore] public string ProteinAccession { get; internal set; }

    [Ignore] private string? _fileNameWithoutExtensions;
    [Ignore] public string FileNameWithoutExtension => _fileNameWithoutExtensions ??= Path.GetFileNameWithoutExtension(RawFileName);
    [Ignore] public double ConfidenceMetric => QValue;
    [Ignore] public double SecondaryConfidenceMetric => 1 - Pep;
    [Ignore] public bool PassesConfidenceFilter => QValue <= 0.01;

    [Ignore] private string? _fullSequence;
    [Ignore] public string FullSequence
    {
        get
        {
            if (_fullSequence != null)
                return _fullSequence;
            if (!OneBasedModificationDictionary.Any())
                return _fullSequence = BaseSequence;

            var sb = new StringBuilder();

            if (OneBasedModificationDictionary.Any(p => p.Key == 0))
            {
                var modToAdd = OneBasedModificationDictionary.FirstOrDefault(p => p.Key == 0).Value;
                if (modToAdd is not null)
                    sb.Append(modToAdd.GetMetaMorpheusFullSequenceString(GlobalVariables.AllModsKnown));
            }
            for (int i = 0; i < BaseSequence.Length; i++)
            {
                var residue = BaseSequence[i];
                sb.Append(residue);

                var potentialMod = OneBasedModificationDictionary.FirstOrDefault(p => p.Key == i + 1).Value;
                if (potentialMod is null) continue;

                var mmMod = potentialMod.GetMetaMorpheusFullSequenceString(GlobalVariables.AllModsKnown);
                sb.Append(mmMod);
            }

            // Use a single StringBuilder to avoid multiple string allocations from chained Replace calls
            var fullSeq = sb.ToString();
            var replacements = new (string oldValue, string newValue)[]
            {
                ("Phospho on Y", "Phosphorylation on Y"),
                ("Phospho on T", "Phosphorylation on T"),
                ("Phospho on S", "Phosphorylation on S"),
                ("Acetyl on X", "Acetylation on X"),
                ("Acetyl on K", "Acetylation on K")
            };

            var resultBuilder = new StringBuilder(fullSeq.Length);
            int lastIndex = 0;
            foreach (var (oldValue, newValue) in replacements)
            {
                int index = fullSeq.IndexOf(oldValue, lastIndex, StringComparison.Ordinal);
                while (index != -1)
                {
                    resultBuilder.Append(fullSeq, lastIndex, index - lastIndex);
                    resultBuilder.Append(newValue);
                    lastIndex = index + oldValue.Length;
                    index = fullSeq.IndexOf(oldValue, lastIndex, StringComparison.Ordinal);
                }
                if (lastIndex < fullSeq.Length)
                {
                    resultBuilder.Append(fullSeq, lastIndex, fullSeq.Length - lastIndex);
                }
                fullSeq = resultBuilder.ToString();
                resultBuilder.Clear();
                lastIndex = 0;
            }
            return _fullSequence = fullSeq;
        }
    }

    [Name("MODIFIED_SEQUENCE")]
    [TypeConverter(typeof(ChimerysFullSequenceToModificationConverter))]
    public Dictionary<int, Modification> OneBasedModificationDictionary { get; set; }

    [Name("PSM_ID")]
    public long PsmId { get; set; }

    [Name("SEQUENCE")]
    public string BaseSequence { get; set; }


    [Name("MODIFIED_SEQUENCE")]
    public string ModifiedSequence { get; set; }

    [Name("MISSED_CLEAVAGES")]
    public int MissedCleavages { get; set; }

    [Name("MASS")]
    public double MonoisotopicMass { get; set; }

    [Name("PRECURSOR_CHARGE")]
    public int PrecursorCharge { get; set; }

    [Name("LENGTH")]
    public int Length { get; set; }

    [Name("M_Z")]
    public double Mz { get; set; }

    [Name("SCAN_NUMBER_IN_FILE")]
    public int OneBasedScanNumber { get; set; }

    [Name("RETENTION_TIME")]
    public double RetentionTime { get; set; }

    [Name("RETENTION_TIME_PREDICTION")]
    public double RetentionTimePrediction { get; set; }

    /// <summary>
    /// The coefficient is the output of our deconvolution function and can be understood
    /// as the summed MS2 intensity of all matched fragments for this peptide.
    /// </summary>
    [Name("COEFF")]
    public double Coeff { get; set; }

    [Name("SPECTRAL_ANGLE")]
    public double SpectralAngle { get; set; }

    /// <summary>
    /// The CTP score combines the spectral angle and the ratio of predicted and matched fragment ions.
    /// It ranged from 0-1, with 1 being best.
    /// </summary>
    [Name("CTP")]
    public double Ctp { get; set; }

    [Name("MATCHED_PEAKS")]
    public int MatchedFragmentIonCount { get; set; }

    /// <summary>
    /// Top peaks are the highest peaks of the prediction.
    /// Minimum three out of the five highest predicted peaks must be matched.
    /// Number of top peaks matched until maximum two peaks are missed.
    /// </summary>
    [Name("TOP_PEAKS_SHARED")]
    public int TopPeaksShared { get; set; }

    [Name("IS_AMBIGUOUS")]
    public bool IsAmbiguous { get; set; }

    [Name("RAW_FILE_NAME")]
    public string RawFileName { get; set; }

    [Name("SAMPLE_NAME")]
    public string SampleName { get; set; }

    [Name("Q_VALUE")]
    public double QValue { get; set; }

    [Name("SE_SCORE")]
    public double SearchEngineScore { get; set; }

    [Name("PEP")]
    public double Pep { get; set; }

    [Name("DECOY")]
    public bool IsDecoy { get; set; }

    [Name("PRECURSOR_ID")]
    public long PrecursorId { get; set; }

    [Name("MODIFIED_PEPTIDE_ID")]
    public long ModifiedPeptideId { get; set; }

    [Name("PEPTIDE_ID")]
    public long PeptideId { get; set; }

    /// <summary>
    /// Starting amino acid position of this peptide in its Protein.
    /// </summary>
    [Name("POSITION_IN_PROTEIN_IDS")]
    [TypeConverter(typeof(SemicolonDelimitedToIntegerArrayConverter))]
    public int[] PositionInProteinIds { get; set; }

    /// <summary>
    /// One or several numeric protein identifiers for the precursor
    /// </summary>
    [Name("PROTEIN_IDS")]
    [TypeConverter(typeof(SemicolonDelimitedToLongArrayConverter))]
    public long[] ProteinIds { get; set; }

    [Name("LOCALIZATION_SEQUENCE")]
    public string? LocalizationSequence { get; set; }

    [Name("LOCALIZATION_SCORE")]
    public double? LocalizationScore { get; set; }

    [Name("PROTEIN_SITES")]
    public string? ProteinSites { get; set; }

}